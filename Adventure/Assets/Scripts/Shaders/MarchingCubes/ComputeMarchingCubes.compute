#pragma kernel Marche

struct GeneratedVertex {
    float3 position;
    float3 normal;
    float3 uv0;
    float3 uv1;
};

StructuredBuffer<int> TriangleTable;
RWStructuredBuffer<uint> CounterIndex;

RWStructuredBuffer<GeneratedVertex> VertexBuffer;
RWStructuredBuffer<uint> IndexBuffer;
        
StructuredBuffer<float> VoxelBuffer;
StructuredBuffer<float> MaterialBuffer;

//
// Input Voxels
//
float SampleVoxel(uint3 pos) {
    return VoxelBuffer[pos.x + pos.y * 9 + pos.z * 81];
}

float SampleMaterial(uint3 pos) {
    return MaterialBuffer[pos.x + pos.y * 9 + pos.z * 81];
}

float SampleFloatVoxel(float x, float y, float z) {
    int mx = floor(x);
    int my = floor(y);
    int mz = floor(z);
    int bx = mx + 1;
    int by = my + 1;
    int bz = mz + 1;
    float c = SampleVoxel(uint3(mx, my, mz));
    float x1 = SampleVoxel(uint3(bx, my, mz));
    float y1 = SampleVoxel(uint3(mx, by, mz));
    float z1 = SampleVoxel(uint3(mx, my, bz));
    float xy = SampleVoxel(uint3(bx, by, mz));
    float yz = SampleVoxel(uint3(mx, by, bz));
    float zx = SampleVoxel(uint3(bx, my, bz));
    float xyz = SampleVoxel(uint3(bx, by, bz));

    float ix1 = lerp(c, x1, x - mx);
    float ix2 = lerp(y1, xy, x - mx);
    float iy1 = lerp(ix1, ix2, y - my);
	    
    float ix3 = lerp(z1, zx, x - mx);
    float ix4 = lerp(yz, xyz, x - mx);
    float iy2 = lerp(ix3, ix4, y - my);

    return lerp(iy1, iy2, z - mz);
}

float3 GetSurfaceNormal(float3 pos) {
    float d = 0.025f;
    float v_nx = SampleFloatVoxel(pos.x - d, pos.y, pos.z) - .5f;
    float v_px = SampleFloatVoxel(pos.x + d, pos.y, pos.z) - .5f;
    float v_ny = SampleFloatVoxel(pos.x, pos.y - d, pos.z) - .5f;
    float v_py = SampleFloatVoxel(pos.x, pos.y + d, pos.z) - .5f;
    float v_nz = SampleFloatVoxel(pos.x, pos.y, pos.z - d) - .5f;
    float v_pz = SampleFloatVoxel(pos.x, pos.y, pos.z + d) - .5f;
    return -normalize(float3(v_px - v_nx, v_py - v_ny, v_pz - v_nz));
}

//
// Output buffer and counter
//

// Vertex buffer accessor
void WriteVertex(uint offset, float3 p, float3 n, float3 uv0, float3 uv1) {
    GeneratedVertex vertex;
    vertex.position = p;
    vertex.normal = n;
    vertex.uv0 = uv0;
    vertex.uv1 = uv1;
    VertexBuffer[offset] = vertex;
}

// Index buffer accessor
void WriteIndex(uint index) {
    IndexBuffer[index] = index;
    IndexBuffer[index + 1] = index + 1;
    IndexBuffer[index + 2] = index + 2;
}

//
// Cube geometry/topology
//

uint3 CubeVertex(uint index) {
    // (0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0),
    // (0, 0, 1), (1, 0, 1), (1, 1, 1), (0, 1, 1)
    bool x = index & 1;
    bool y = index & 2;
    bool z = index & 4;
    return uint3(x ^ y, y, z);
}

uint2 EdgeVertexPair(uint index) {
    // (0, 1) (1, 2) (2, 3) (3, 0)
    // (4, 5) (5, 6) (6, 7) (7, 4)
    // (0, 4) (1, 5) (2, 6) (3, 7)
    uint v1 = index & 7;
    uint v2 = index < 8 ? ((index + 1) & 3) | (index & 4) : v1 + 4;
    return uint2(v1, v2);
}

[numthreads(8, 8, 8)]
void Marche(uint3 id : SV_DispatchThreadID) {
    uint selector = 0;
    float samples[8];
    for (uint i = 0; i < 8; i++) {
        samples[i] = SampleVoxel(id + CubeVertex(i));
        selector |= (samples[i] < 0.5) << i;
    }
    
    if (selector == 0 || selector == 0xff) return;
    
    float3 vertices[12];
    float3 normals[12];
    float material[12];
    for (uint i = 0; i < 12; i++) {
        const uint2 pair = EdgeVertexPair(i);
        const float sample1 = samples[pair.x];
        const float sample2 = samples[pair.y];
        const float3 vertex1 = id + CubeVertex(pair.x);
        const float3 vertex2 = id + CubeVertex(pair.y);
        const float param = (0.5 - sample1) / (sample2 - sample1);
        
        vertices[i] = lerp(vertex1, vertex2, param);
        normals[i] = GetSurfaceNormal(vertices[i]);
        material[i] = SampleMaterial(sample1 > sample2 ? vertex1 : vertex2);

        if (normals[i].x > 0.99 && abs(normals[i].y) < 0.01 && abs(normals[i].z) < 0.01) normals[i].xyz = float3(0.99, 0.01, 0.01);
        if (normals[i].x < -0.99 && abs(normals[i].y) < 0.01 && abs(normals[i].z) < 0.01) normals[i].xyz = float3(-0.99, 0.01, 0.01);
    }

    const uint table_index = selector * 18;
    for (uint i = 0; i < 18; i+= 3) {
        const int t_index0 = TriangleTable[table_index + i];
        const int t_index1 = TriangleTable[table_index + i + 1];
        const int t_index2 = TriangleTable[table_index + i + 2];
        if (t_index0 < 0) return;
        
        uint index;
        InterlockedAdd(CounterIndex[0], 3, index);

        const float3 uv0 = float3(material[t_index0], material[t_index1], material[t_index2]);
        WriteVertex(index    , vertices[t_index0], normals[t_index0], uv0, float3(1, 0, 0));
        WriteVertex(index + 1, vertices[t_index1], normals[t_index1], uv0, float3(0, 1, 0));
        WriteVertex(index + 2, vertices[t_index2], normals[t_index2], uv0, float3(0, 0, 1));
        WriteIndex(index);
    }
}