#pragma kernel Marche

struct GeneratedVertex {
    float3 position;
    float3 normal;
    float2 uv;
};

StructuredBuffer<int> TriangleTable;
RWStructuredBuffer<uint> CounterIndex;
RWStructuredBuffer<uint> CounterVertex;

RWStructuredBuffer<GeneratedVertex> VertexBuffer;
RWStructuredBuffer<uint> IndexBuffer;
        
StructuredBuffer<float> VoxelBuffer;
//RWByteAddressBuffer MaterialBuffer;

//
// Input Voxels
//
float SampleVoxel(uint3 pos) {
    return VoxelBuffer[pos.x + pos.y * 9 + pos.z * 81];
}

float SampleFloatVoxel(float x, float y, float z) {
    int mx = floor(x);
    int my = floor(y);
    int mz = floor(z);
    int bx = mx + 1;
    int by = my + 1;
    int bz = mz + 1;
    float c = SampleVoxel(uint3(mx, my, mz));
    float x1 = SampleVoxel(uint3(bx, my, mz));
    float y1 = SampleVoxel(uint3(mx, by, mz));
    float z1 = SampleVoxel(uint3(mx, my, bz));
    float xy = SampleVoxel(uint3(bx, by, mz));
    float yz = SampleVoxel(uint3(mx, by, bz));
    float zx = SampleVoxel(uint3(bx, my, bz));
    float xyz = SampleVoxel(uint3(bx, by, bz));

    float ix1 = lerp(c, x1, x - mx);
    float ix2 = lerp(y1, xy, x - mx);
    float iy1 = lerp(ix1, ix2, y - my);
	    
    float ix3 = lerp(z1, zx, x - mx);
    float ix4 = lerp(yz, xyz, x - mx);
    float iy2 = lerp(ix3, ix4, y - my);

    return lerp(iy1, iy2, z - mz);
}

float3 GetSurfaceNormal(uint3 pos) {
    float d = 0.025f;
    float v_nx = SampleFloatVoxel(pos.x - d, pos.y, pos.z) - .5f;
    float v_px = SampleFloatVoxel(pos.x + d, pos.y, pos.z) - .5f;
    float v_ny = SampleFloatVoxel(pos.x, pos.y - d, pos.z) - .5f;
    float v_py = SampleFloatVoxel(pos.x, pos.y + d, pos.z) - .5f;
    float v_nz = SampleFloatVoxel(pos.x, pos.y, pos.z - d) - .5f;
    float v_pz = SampleFloatVoxel(pos.x, pos.y, pos.z + d) - .5f;
    return -normalize(float3(v_px - v_nx, v_py - v_ny, v_pz - v_nz));
}

float4 VoxelValue(uint3 pos) {
    float3 v = GetSurfaceNormal(pos);
    return float4(v.x, v.y, v.z, SampleVoxel(pos));
}

//
// Output buffer and counter
//

// Vertex buffer accessor
void WriteVertex(uint offset, float3 p, float3 n) {
    GeneratedVertex vertex;
    vertex.position = p;
    vertex.normal = n;
    vertex.uv = float2(0, 0);
    VertexBuffer[offset] = vertex;
}

// Index buffer accessor
void WriteIndex(uint offset, uint index, uint index2, uint index3) {
    IndexBuffer[offset] = index;
    IndexBuffer[offset + 1] = index2;
    IndexBuffer[offset + 2] = index3;
}

//
// Cube geometry/topology
//

uint3 CubeVertex(uint index) {
    // (0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0),
    // (0, 0, 1), (1, 0, 1), (1, 1, 1), (0, 1, 1)
    bool x = index & 1;
    bool y = index & 2;
    bool z = index & 4;
    return uint3(x ^ y, y, z);
}

uint2 EdgeVertexPair(uint index) {
    // (0, 1) (1, 2) (2, 3) (3, 0)
    // (4, 5) (5, 6) (6, 7) (7, 4)
    // (0, 4) (1, 5) (2, 6) (3, 7)
    uint v1 = index & 7;
    uint v2 = index < 8 ? ((index + 1) & 3) | (index & 4) : v1 + 4;
    return uint2(v1, v2);
}

[numthreads(8, 8, 8)]
void Marche(uint3 id : SV_DispatchThreadID) {
    
    // Cube configuration selector
    uint selector = 0;
    float4 samples[8];
    for (uint i = 0; i < 8; i++) {
        samples[i] = VoxelValue(id + CubeVertex(i));
        selector |= (samples[i].w > 0.5) << i;
    }
    
    if (selector == 0 || selector == 0xff) return;
    
    uint indices[12];
    float3 vertices[12];
    float3 normals[12];
    for (uint i = 0; i < 12; i++) {
        uint2 pair = EdgeVertexPair(i);
        float4 sample1 = samples[pair.x];
        float4 sample2 = samples[pair.y];
        float3 vertex1 = id + CubeVertex(pair.x);
        float3 vertex2 = id + CubeVertex(pair.y);
        float param = (0.5 - sample1.w) / (sample2.w - sample1.w);
        vertices[i] = lerp(vertex1, vertex2, param);
        normals[i] = -normalize(lerp(sample1.xyz, sample2.xyz, param));

        if (sample1.w > 0.5 != sample2.w > 0.5) {
            InterlockedAdd(CounterVertex[0], 1, indices[i]);
            WriteVertex(indices[i], vertices[i], normals[i]);
        }
    }

    const uint tableIndex = selector * 18;
    for (uint i = 0; i < 18; i+= 3) {
        int tIndex = TriangleTable[tableIndex + i];
        int tIndex1 = TriangleTable[tableIndex + i + 1];
        int tIndex2 = TriangleTable[tableIndex + i + 2];
        if (tIndex < 0) return;
        
        uint index;
        InterlockedAdd(CounterIndex[0], 3, index);
        WriteIndex(index, indices[tIndex], indices[tIndex1], indices[tIndex2]);
    }
}