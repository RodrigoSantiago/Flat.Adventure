#pragma kernel Marche
#pragma kernel Swim
#pragma kernel BakeSolid
#pragma kernel BakeLiquid

struct GeneratedVertex {
    float3 position;
    float3 normal;
    float4 uv0;
};
struct GeneratedVertexLow {
    uint2 position;
    uint2 normal;
    uint2 uv0;
};

#define SIZE 20
#define SIZE2 400
#define SIZE3 8000
#define NORMD 0.025

StructuredBuffer<int> TriangleTable;
        
StructuredBuffer<float2> VoxelBuffer;
RWStructuredBuffer<uint> CounterSolid;
RWStructuredBuffer<uint> CounterLiquid;

RWStructuredBuffer<GeneratedVertex> VertexSolid;

RWStructuredBuffer<GeneratedVertex> VertexLiquid;

RWStructuredBuffer<GeneratedVertexLow> MeshVertexBuffer;
RWStructuredBuffer<uint> MeshIndexBuffer;

//
// Input Voxels
//
float2 GetVox(const uint x, const uint y, const uint z) {
    return VoxelBuffer[x + 2 + (y + 2) * SIZE + (z + 2) * SIZE2];
}

float2 SampleSolid(const uint3 pos) {
    const float2 vox = GetVox(pos.x, pos.y, pos.z);
    return float2(max(sign(vox.y + 1), 0) * vox.x, vox.y);
}

float3 SampleLiquid(const uint3 pos) {
    const float2 vox = GetVox(pos.x, pos.y, pos.z);
    return float3(max(-sign(vox.y + 1), 0) * vox.x, vox.y, ceil(vox.x));
}

float SampleVoxel(const uint3 pos) {
    const float2 vox = GetVox(pos.x, pos.y, pos.z);
    return max(sign(vox.y + 1), 0) * vox.x;
}

float SampleVoxelL(const uint x, const uint y, const uint z) {
    const float2 vox = GetVox(x, y, z);
    return max(-sign(vox.y + 1), 0) * vox.x;
}

float SampleVoxelLiquid(const uint3 pos) {
    const float2 vox0 = GetVox(pos.x, pos.y, pos.z);
    const float vox1 = SampleVoxelL(pos.x+1, pos.y, pos.z);
    const float vox2 = SampleVoxelL(pos.x-1, pos.y, pos.z);
    const float vox3 = SampleVoxelL(pos.x, pos.y+1, pos.z);
    const float vox4 = SampleVoxelL(pos.x, pos.y-1, pos.z);
    const float vox5 = SampleVoxelL(pos.x, pos.y, pos.z+1);
    const float vox6 = SampleVoxelL(pos.x, pos.y, pos.z-1);
    return vox0.y < 0 || vox0.x <= 0 ? vox0.x : max(max(max(max(max(vox1, vox2), vox3), vox4), vox5), vox6);
}

float3 GetSurfaceNormal(const float3 pos) {
    const int3 base = floor(pos);
    const float fra = length(pos - base);
    const int3 si0 = ceil(pos - base);
    const int3 si1 = int3(si0.z, si0.x, si0.y);
    const int3 si2 = int3(si0.y, si0.z, si0.x);
    
    const float coord_a0 = SampleVoxel(base);
    const float coord_a1 = SampleVoxel(base + si0);

    const float coord_b0 = SampleVoxel(base + si1);
    const float coord_b1 = SampleVoxel(base + si1 + si0);
    const float coord_b2 = SampleVoxel(base - si1);
    const float coord_b3 = SampleVoxel(base - si1 + si0);

    const float coord_c0 = SampleVoxel(base + si2);
    const float coord_c1 = SampleVoxel(base + si2 + si0);
    const float coord_c2 = SampleVoxel(base - si2);
    const float coord_c3 = SampleVoxel(base - si2 + si0);

    const float lerp_a0 = lerp(coord_a0, coord_a1, fra); // The Center. Always 0.5 = On Surface
    const float lerp_b0 = lerp(coord_b0, coord_b1, fra);
    const float lerp_b2 = lerp(coord_b2, coord_b3, fra);
    const float lerp_c0 = lerp(coord_c0, coord_c1, fra);
    const float lerp_c2 = lerp(coord_c2, coord_c3, fra);

    const float na0 = lerp(coord_a0, coord_a1, fra + NORMD) - .5f;
    const float na2 = lerp(coord_a0, coord_a1, fra - NORMD) - .5f;
    const float nb0 = lerp(lerp_a0, lerp_b0, NORMD) - .5f;
    const float nb2 = lerp(lerp_a0, lerp_b2, NORMD) - .5f;
    const float nc0 = lerp(lerp_a0, lerp_c0, NORMD) - .5f;
    const float nc2 = lerp(lerp_a0, lerp_c2, NORMD) - .5f;

    const float3 sa = si0 * (na0 - na2);
    const float3 sb = si1 * (nb0 - nb2);
    const float3 sc = si2 * (nc0 - nc2);
    return -normalize(sa + sb + sc);
}

float3 GetSurfaceNormalLiquid(float3 pos) {
    const int3 base = floor(pos);
    const float fra = length(pos - base);
    const int3 si0 = ceil(pos - base);
    const int3 si1 = int3(si0.z, si0.x, si0.y);
    const int3 si2 = int3(si0.y, si0.z, si0.x);
    
    const float coord_a0 = SampleVoxelLiquid(base);
    const float coord_a1 = SampleVoxelLiquid(base + si0);

    const float coord_b0 = SampleVoxelLiquid(base + si1);
    const float coord_b1 = SampleVoxelLiquid(base + si1 + si0);
    const float coord_b2 = SampleVoxelLiquid(base - si1);
    const float coord_b3 = SampleVoxelLiquid(base - si1 + si0);

    const float coord_c0 = SampleVoxelLiquid(base + si2);
    const float coord_c1 = SampleVoxelLiquid(base + si2 + si0);
    const float coord_c2 = SampleVoxelLiquid(base - si2);
    const float coord_c3 = SampleVoxelLiquid(base - si2 + si0);

    const float lerp_a0 = lerp(coord_a0, coord_a1, fra); // The Center. Always 0.5 = On Surface
    const float lerp_b0 = lerp(coord_b0, coord_b1, fra);
    const float lerp_b2 = lerp(coord_b2, coord_b3, fra);
    const float lerp_c0 = lerp(coord_c0, coord_c1, fra);
    const float lerp_c2 = lerp(coord_c2, coord_c3, fra);

    const float na0 = lerp(coord_a0, coord_a1, fra + NORMD) - .5f;
    const float na2 = lerp(coord_a0, coord_a1, fra - NORMD) - .5f;
    const float nb0 = lerp(lerp_a0, lerp_b0, NORMD) - .5f;
    const float nb2 = lerp(lerp_a0, lerp_b2, NORMD) - .5f;
    const float nc0 = lerp(lerp_a0, lerp_c0, NORMD) - .5f;
    const float nc2 = lerp(lerp_a0, lerp_c2, NORMD) - .5f;

    const float3 sa = si0 * (na0 - na2);
    const float3 sb = si1 * (nb0 - nb2);
    const float3 sc = si2 * (nc0 - nc2);
    return -normalize(sa + sb + sc);
}

//
// Output buffer and counter
//

// Vertex buffer accessor
void WriteVertex(const uint offset, const float3 p, const float3 n, const float3 uv0, const float uv1) {
    GeneratedVertex vertex;
    vertex.position = p;
    vertex.normal = n;
    vertex.uv0 = float4(uv0.x, uv0.y, uv0.z, uv1);
    VertexSolid[offset] = vertex;
}

void WriteVertexLiquid(const uint offset, const float3 p, const float3 n, const float3 uv0, const float uv1) {
    GeneratedVertex vertex;
    vertex.position = p;
    vertex.normal = n;
    vertex.uv0 = float4(uv0.x, uv0.y, uv0.z, uv1);
    VertexLiquid[offset] = vertex;
}

//
// Cube geometry/topology
//

uint3 CubeVertex(const uint index) {
    // (0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0),
    // (0, 0, 1), (1, 0, 1), (1, 1, 1), (0, 1, 1)
    const bool x = index & 1;
    const bool y = index & 2;
    const bool z = index & 4;
    return uint3(x ^ y, y, z);
}

uint2 EdgeVertexPair(const uint index) {
    // (0, 1) (1, 2) (2, 3) (3, 0)
    // (4, 5) (5, 6) (6, 7) (7, 4)
    // (0, 4) (1, 5) (2, 6) (3, 7)
    const uint v1 = index & 7;
    const uint v2 = index < 8 ? ((index + 1) & 3) | (index & 4) : v1 + 4;
    return uint2(v1, v2);
}

[numthreads(4, 4, 4)]
void Marche(uint3 id : SV_DispatchThreadID) {
    
    uint selector = 0;
    float2 samples[8];
    uint i;
    for (i = 0; i < 8; i++) {
        samples[i] = SampleSolid(id + CubeVertex(i));
        selector |= (samples[i].x < 0.5) << i;
    }
    
    if (selector == 0 || selector == 0xff) return;
    
    float3 vertices[12];
    float3 normals[12];
    float material[12];
    for (i = 0; i < 12; i++) {
        const uint2 pair = EdgeVertexPair(i);
        const float2 sample1 = samples[pair.x];
        const float2 sample2 = samples[pair.y];
        const float3 vertex1 = id + CubeVertex(pair.x);
        const float3 vertex2 = id + CubeVertex(pair.y);
        const float param = (0.5 - sample1.x) / (sample2.x - sample1.x);
        
        vertices[i] = lerp(vertex1, vertex2, param);
        normals[i] = GetSurfaceNormal(vertices[i]);
        material[i] = abs(
            sample1.x == 0 ? sample2.y :
            sample2.x == 0 ? sample1.y :param < 0.5 ? sample1.y : sample2.y);

        const uint condition = abs(normals[i].x) > 0.99 && abs(normals[i].y) < 0.01 && abs(normals[i].z) < 0.01;
        normals[i].xyz = lerp(normals[i].xyz, float3(sign(normals[i].x) * 0.99, 0.01, 0.01), condition);
    }

    const uint table_index = selector * 18;
    for (i = 0; i < 18; i+= 3) {
        const int t_index0 = TriangleTable[table_index + i];
        const int t_index1 = TriangleTable[table_index + i + 1];
        const int t_index2 = TriangleTable[table_index + i + 2];
        if (t_index0 < 0) return;
        
        uint index;
        InterlockedAdd(CounterSolid[0], 3, index);

        const float3 uv0 = float3(material[t_index0], material[t_index1], material[t_index2]);
        WriteVertex(index    , vertices[t_index0], normals[t_index0], uv0, 1);
        WriteVertex(index + 1, vertices[t_index1], normals[t_index1], uv0, 2);
        WriteVertex(index + 2, vertices[t_index2], normals[t_index2], uv0, 3);
    }
}

[numthreads(4, 4, 4)]
void Swim(uint3 id : SV_DispatchThreadID) {
    uint left[8]  = {4, 0, 1, 2, 7, 4, 5, 3};
    uint right[8] = {3, 2, 3, 0, 5, 1, 7, 6};
    uint top[8]   = {1, 5, 6, 7, 0, 6, 2, 4};
    
    float samplesi[8];
    float3 samples[8];
    uint i;
    for (i = 0; i < 8; i++) {
        samples[i] = SampleLiquid(id + CubeVertex(i));
        samplesi[i] = samples[i].x;
    }

    uint selector = 0;
    for (i = 0; i < 8; i++) {
        samples[i].x += (samples[i].y >= 0) * samples[i].z *
                        max(max(samplesi[left[i]], samplesi[right[i]]), samplesi[top[i]]);
        
        selector |= (samples[i].x < 0.5) << i;
    }
    
    if (selector == 0 || selector == 0xff) return;
    
    float3 vertices[12];
    float3 normals[12];
    float material[12];
    for (i = 0; i < 12; i++) {
        const uint2 pair = EdgeVertexPair(i);
        const float3 sample1 = samples[pair.x];
        const float3 sample2 = samples[pair.y];
        const float3 vertex1 = id + CubeVertex(pair.x);
        const float3 vertex2 = id + CubeVertex(pair.y);
        const float param = (0.5 - sample1.x) / (sample2.x - sample1.x);
        
        vertices[i] = lerp(vertex1, vertex2, param);
        normals[i] = GetSurfaceNormalLiquid(vertices[i]);
        material[i] = abs(
            sample1.x == 0 ? sample2.y :
            sample2.x == 0 ? sample1.y :param < 0.5 ? sample1.y : sample2.y);

        const uint condition = abs(normals[i].x) > 0.99 && abs(normals[i].y) < 0.01 && abs(normals[i].z) < 0.01;
        normals[i].xyz = lerp(normals[i].xyz, float3(sign(normals[i].x) * 0.99, 0.01, 0.01), condition);
    }

    const uint table_index = selector * 18;
    for (i = 0; i < 18; i+= 3) {
        const int t_index0 = TriangleTable[table_index + i];
        const int t_index1 = TriangleTable[table_index + i + 1];
        const int t_index2 = TriangleTable[table_index + i + 2];
        if (t_index0 < 0) return;
        
        uint index;
        InterlockedAdd(CounterLiquid[0], 3, index);

        const float3 uv0 = float3(material[t_index0], material[t_index1], material[t_index2]);
        WriteVertexLiquid(index    , vertices[t_index0], normals[t_index0], uv0, 1);
        WriteVertexLiquid(index + 1, vertices[t_index1], normals[t_index1], uv0, 2);
        WriteVertexLiquid(index + 2, vertices[t_index2], normals[t_index2], uv0, 3);
    }
}

[numthreads(64, 1, 1)]
void BakeSolid(uint3 id : SV_DispatchThreadID) {
    const uint index = id.x;
    GeneratedVertex ver = VertexSolid[index];
    GeneratedVertexLow low;
    low.position.x = f32tof16(ver.position.x) | (f32tof16(ver.position.y) << 16);
    low.position.y = f32tof16(ver.position.z);
    low.normal.x = f32tof16(ver.normal.x) | (f32tof16(ver.normal.y) << 16);
    low.normal.y = f32tof16(ver.normal.z);
    low.uv0.x = f32tof16(ver.uv0.x) | (f32tof16(ver.uv0.y) << 16);
    low.uv0.y = f32tof16(ver.uv0.z) | (f32tof16(ver.uv0.w) << 16);
    MeshVertexBuffer[index * 6] = low;
    MeshIndexBuffer[index / 2] = (index & 0xFFFE) | ((index | 1) << 16);
}

[numthreads(64, 1, 1)]
void BakeLiquid(uint3 id : SV_DispatchThreadID) {
    const uint index = id.x;
    GeneratedVertex ver = VertexLiquid[index];
    GeneratedVertexLow low;
    low.position.x = f32tof16(ver.position.x) | (f32tof16(ver.position.y) << 16);
    low.position.y = f32tof16(ver.position.z);
    low.normal.x = f32tof16(ver.normal.x) | (f32tof16(ver.normal.y) << 16);
    low.normal.y = f32tof16(ver.normal.z);
    low.uv0.x = f32tof16(ver.uv0.x) | (f32tof16(ver.uv0.y) << 16);
    low.uv0.y = f32tof16(ver.uv0.z) | (f32tof16(ver.uv0.w) << 16);
    MeshVertexBuffer[index * 6] = low;
    MeshIndexBuffer[index / 2] = (index & 0xFFFE) | ((index | 1) << 16);
}